<?php

namespace App\Helpers;

use App\Models\SeoMeta;
use Illuminate\Support\Str;

class SeoHelper
{
    /**
     * Получить SEO данные для страницы
     *
     * @param string $pageType Тип страницы (home, report, profile, etc.)
     * @param mixed $pageId ID конкретной страницы (опционально)
     * @param array $variables Переменные для подстановки в шаблоны
     * @param string|null $routeName Название роута (опционально)
     * @return array
     */
    public static function get(string $pageType, $pageId = null, array $variables = [], ?string $routeName = null): array
    {
        // Добавляем базовые переменные
        $variables = array_merge([
            'site_name' => config('seo.site_name', 'Дневник сновидений'),
            'site_description' => config('seo.site_description', ''),
        ], $variables);

        // Пытаемся найти переопределение в БД
        $override = SeoMeta::getForPage($pageType, $pageId, $routeName);

        // Получаем базовый шаблон из конфига
        $template = config("seo.templates.{$pageType}", []);

        // Объединяем: переопределение имеет приоритет над шаблоном
        $seoData = array_merge($template, $override ? $override->toArray() : []);

        // Обрабатываем шаблоны: заменяем плейсхолдеры
        $result = [];
        foreach ($seoData as $key => $value) {
            if ($value !== null && is_string($value)) {
                $result[$key] = self::replacePlaceholders($value, $variables);
            } elseif ($value !== null) {
                $result[$key] = $value;
            }
        }

        // Если og_title или og_description не указаны, используем title/description
        if (empty($result['og_title']) && !empty($result['title'])) {
            $result['og_title'] = $result['title'];
        }
        if (empty($result['og_description']) && !empty($result['description'])) {
            $result['og_description'] = $result['description'];
        }

        // Формируем полный URL для OG изображения
        if (!empty($result['og_image'])) {
            // Если это относительный путь, делаем абсолютным
            if (!Str::startsWith($result['og_image'], ['http://', 'https://'])) {
                $baseUrl = rtrim(config('seo.base_url', config('app.url')), '/');
                $result['og_image'] = $baseUrl . '/' . ltrim($result['og_image'], '/');
            }
        } else {
            // Используем дефолтное изображение
            $baseUrl = rtrim(config('seo.base_url', config('app.url')), '/');
            $defaultImage = ltrim(config('seo.default_og_image', '/images/og-default.jpg'), '/');
            $result['og_image'] = $baseUrl . '/' . $defaultImage;
        }

        // Обрезаем description до 160 символов (стандарт для SEO)
        if (!empty($result['description'])) {
            $result['description'] = Str::limit($result['description'], 160, '...');
        }
        if (!empty($result['og_description'])) {
            $result['og_description'] = Str::limit($result['og_description'], 200, '...');
        }

        // Формируем canonical URL
        $result['canonical'] = self::generateCanonicalUrl($pageType, $pageId, $variables);

        return $result;
    }

    /**
     * Получить SEO для отчета
     */
    public static function forReport($report): array
    {
        $firstDream = $report->dreams->first();
        $nickname = $report->user->nickname ?? $report->user->name;
        $date = $report->report_date->format('d.m.Y');
        
        // Собираем все названия снов (не пустые)
        $dreamTitles = $report->dreams
            ->pluck('title')
            ->filter(function ($title) {
                return !empty($title) && trim($title) !== '';
            })
            ->values();
        
        // Определяем dream_title
        $dreamTitle = '';
        $hasRealTitles = false;
        
        if ($dreamTitles->isEmpty()) {
            // Нет ни одного названия
            $dreamTitle = 'Отчёт ' . $nickname . ' о сновидениях за ' . $date;
        } else {
            // Проверяем, является ли название автогенерированным
            // Шаблоны автогенерированных названий: "Отчет {nickname} от {date}" или "Сон от {date}"
            $firstTitle = $dreamTitles->first();
            $isAutoGenerated = false;
            
            if ($dreamTitles->count() === 1) {
                // Варианты автогенерированных названий:
                // "Отчет {nickname} от {date}" (из ReportController)
                // "Отчет от {date}"
                // "Сон от {date}"
                $pattern1 = "Отчет {$nickname} от {$date}";
                $pattern2 = "Отчет от {$date}";
                $pattern3 = "Сон от {$date}";
                
                if ($firstTitle === $pattern1 || $firstTitle === $pattern2 || $firstTitle === $pattern3) {
                    $isAutoGenerated = true;
                }
                
                // Дополнительная проверка по шаблону (на случай разных вариантов написания)
                if (!$isAutoGenerated) {
                    // Проверяем, если название начинается с "Отчет " или "Сон от" 
                    // и содержит " от " и заканчивается датой формата "дд.мм.гггг"
                    if ((Str::startsWith($firstTitle, 'Отчет ') || Str::startsWith($firstTitle, 'Сон от')) &&
                        Str::contains($firstTitle, ' от ') &&
                        preg_match('/от \d{2}\.\d{2}\.\d{4}$/', $firstTitle)) {
                        $isAutoGenerated = true;
                    }
                }
            }
            
            if ($isAutoGenerated) {
                // Это автогенерированное название, значит реальных названий нет
                $dreamTitle = 'Отчёт ' . $nickname . ' о сновидениях за ' . $date;
            } else {
                // Есть реальные названия - перечисляем через запятую
                $dreamTitle = $dreamTitles->implode(', ');
                $hasRealTitles = true;
            }
        }
        
        $dreamDescription = $firstDream && !empty($firstDream->description)
            ? Str::limit(strip_tags($firstDream->description), 160, '...')
            : 'Отчет о сновидении';

        $tags = $report->tags->pluck('name')->implode(', ');

        // Формируем title с учетом того, содержит ли dream_title уже дату
        // Если это автогенерированное название "Отчёт ... о сновидениях за {date}", 
        // то в шаблоне не нужно дублировать дату
        $seoData = [
            'dream_title' => $dreamTitle,
            'dream_description' => $dreamDescription,
            'date' => $date,
            'nickname' => $nickname,
            'user_name' => $report->user->name ?? '',
            'report_id' => $report->id,
            'tags' => $tags,
        ];

        $seoResult = self::get('report', $report->id, $seoData);

        // Если dream_title уже содержит "о сновидениях за", значит там уже есть дата
        // Убираем дублирование даты из title и og_title
        if (!$hasRealTitles && Str::contains($dreamTitle, 'о сновидениях за')) {
            // Убираем дублирование: заменяем " — {date} |" на " |" в title
            $seoResult['title'] = str_replace(' — ' . $date . ' |', ' |', $seoResult['title']);
            $seoResult['og_title'] = str_replace(' — ' . $date, '', $seoResult['og_title']);
        }

        return $seoResult;
    }

    /**
     * Получить SEO для профиля пользователя
     */
    public static function forProfile($user): array
    {
        $reportsCount = $user->reports()->where('status', 'published')->count();
        $joinedDate = $user->created_at ? $user->created_at->format('d.m.Y') : '';

        return self::get('profile', $user->id, [
            'nickname' => $user->nickname ?? $user->name,
            'name' => $user->name ?? '',
            'reports_count' => $reportsCount,
            'joined_date' => $joinedDate,
        ]);
    }

    /**
     * Получить SEO для публичного дневника
     */
    public static function forDiary($user): array
    {
        $reportsCount = $user->reports()->where('status', 'published')->count();

        return self::get('diary', null, [
            'nickname' => $user->nickname ?? $user->name,
            'name' => $user->name ?? '',
            'reports_count' => $reportsCount,
            'public_link' => $user->public_link ?? '',
        ]);
    }

    /**
     * Заменить плейсхолдеры в шаблоне
     */
    private static function replacePlaceholders(string $template, array $variables): string
    {
        $result = $template;
        foreach ($variables as $key => $value) {
            $result = str_replace('{' . $key . '}', $value, $result);
        }
        return $result;
    }

    /**
     * Сгенерировать canonical URL
     */
    private static function generateCanonicalUrl(string $pageType, $pageId = null, array $variables = []): string
    {
        $baseUrl = rtrim(config('seo.base_url', config('app.url')), '/');

        switch ($pageType) {
            case 'home':
                return $baseUrl . '/';
            case 'report':
                return $baseUrl . '/reports/' . ($pageId ?? $variables['report_id'] ?? '');
            case 'profile':
                return $baseUrl . '/users/' . ($pageId ?? $variables['user_id'] ?? '');
            case 'diary':
                // Для дневника нужен publicLink
                return $baseUrl . '/diary/' . ($variables['public_link'] ?? '');
            case 'search':
                return $baseUrl . '/search';
            case 'activity':
                return $baseUrl . '/activity';
            case 'users':
                return $baseUrl . '/users';
            case 'dashboard':
                return $baseUrl . '/dashboard';
            case 'statistics':
                return $baseUrl . '/statistics';
            case 'notifications':
                return $baseUrl . '/notifications';
            case 'dream-analyzer':
                return $baseUrl . '/tolkovanie-snov';
            case 'dream-analyzer-result':
                return $baseUrl . '/tolkovanie-snov/' . ($variables['hash'] ?? $pageId ?? '');
            default:
                return $baseUrl;
        }
    }
    
    /**
     * Получить SEO для страницы анализатора снов
     */
    public static function forDreamAnalyzer(): array
    {
        return self::get('dream-analyzer');
    }
    
    /**
     * Получить SEO для результата анализа сна
     */
    public static function forDreamAnalyzerResult($interpretation): array
    {
        // Приоритет: сначала нормализованные данные, потом старые
        $result = $interpretation->result ?? null;
        $analysis = $interpretation->analysis_data ?? [];
        
        // Определяем тип анализа
        if ($result) {
            $isSeries = $result->type === 'series';
        } else {
            $isSeries = isset($analysis['series_analysis']) && isset($analysis['dreams']);
        }
        
        if ($isSeries) {
            // Обработка серии снов
            if ($result) {
                // Из нормализованных данных
                $dreamTitle = $result->series_title ?? 'Анализ серии снов';
                $coreMessage = $result->overall_theme ?? '';
                
                // Если нет overall_theme, берем из первого сна в серии
                if (empty($coreMessage) && $result->seriesDreams->isNotEmpty()) {
                    $coreMessage = $result->seriesDreams->first()->summary_insight ?? '';
                }
                
                // Традиции
                $traditions = $result->traditions ?? [];
                $analysisType = $result->analysis_type ?? 'series_integrated';
            } else {
                // Из старых данных
                $seriesAnalysis = $analysis['series_analysis'] ?? [];
                $dreams = $analysis['dreams'] ?? [];
                
                $dreamTitle = $seriesAnalysis['series_title'] ?? 'Анализ серии снов';
                $coreMessage = $seriesAnalysis['overall_theme'] ?? '';
                
                if (empty($coreMessage) && !empty($dreams) && isset($dreams[0]['summary_insight'])) {
                    $coreMessage = $dreams[0]['summary_insight'];
                }
                
                $traditions = $seriesAnalysis['traditions'] ?? [];
                $analysisType = $seriesAnalysis['analysis_type'] ?? 'series_integrated';
            }
            
            // Если все еще пусто, используем дефолтное описание
            if (empty($coreMessage)) {
                $coreMessage = 'Психологический анализ серии снов с использованием различных традиций интерпретации.';
            }
            
            // Традиции - общая обработка
            $traditionsText = '';
            if (!empty($traditions) && is_array($traditions)) {
                $traditionNames = [
                    'freudian' => 'Фрейдистский',
                    'jungian' => 'Юнгианский',
                    'cognitive' => 'Когнитивный',
                    'symbolic' => 'Символический',
                    'shamanic' => 'Шаманистический',
                    'gestalt' => 'Гештальт',
                    'eclectic' => 'Комплексный',
                ];
                
                $translatedTraditions = array_map(function($t) use ($traditionNames) {
                    return $traditionNames[strtolower($t)] ?? ucfirst($t);
                }, $traditions);
                
                $traditionsText = implode(', ', $translatedTraditions);
            }
            
            $analysisTypeText = 'Анализ серии снов';
        } else {
            // Обработка одиночного сна
            if ($result) {
                // Из нормализованных данных
                $dreamTitle = $result->dream_title ?? 'Анализ сна';
                $coreMessage = $result->summary_insight ?? '';
                
                // Традиции
                $traditions = $result->traditions ?? [];
                $analysisType = $result->analysis_type ?? 'single';
            } elseif (isset($analysis['dream_analysis'])) {
                // Новый формат (из analysis_data)
                $dreamAnalysis = $analysis['dream_analysis'] ?? [];
                
                $dreamTitle = $dreamAnalysis['core_theme'] ?? 'Анализ сна';
                $coreMessage = $dreamAnalysis['central_message'] ?? '';
                
                if (empty($coreMessage)) {
                    $coreMessage = $dreamAnalysis['core_theme'] ?? '';
                }
                
                $traditions = [];
                $analysisType = 'single';
            } else {
                // Старый формат (из analysis_data)
                $metadata = $analysis['metadata'] ?? [];
                $analysisData = $analysis['analysis'] ?? [];
                
                $dreamTitle = $metadata['title'] ?? 'Анализ сна';
                $coreMessage = $analysisData['core_message'] ?? '';
                
                if (empty($coreMessage) && isset($analysisData['interpretation'])) {
                    $coreMessage = Str::limit(strip_tags($analysisData['interpretation']), 160, '...');
                }
                
                $traditions = $analysisData['traditions'] ?? [];
                $analysisType = $analysisData['analysis_type'] ?? 'single';
            }
            
            // Если все еще пусто, используем дефолтное описание
            if (empty($coreMessage)) {
                $coreMessage = 'Психологический анализ сна с использованием различных традиций интерпретации.';
            }
            
            // Традиции - общая обработка
            $traditionsText = '';
            if (!empty($traditions) && is_array($traditions)) {
                $traditionNames = [
                    'freudian' => 'Фрейдистский',
                    'jungian' => 'Юнгианский',
                    'cognitive' => 'Когнитивный',
                    'symbolic' => 'Символический',
                    'shamanic' => 'Шаманистический',
                    'gestalt' => 'Гештальт',
                    'eclectic' => 'Комплексный',
                ];
                
                $translatedTraditions = array_map(function($t) use ($traditionNames) {
                    return $traditionNames[strtolower($t)] ?? ucfirst($t);
                }, $traditions);
                
                $traditionsText = implode(', ', $translatedTraditions);
            }
            
            // Тип анализа
            $analysisTypeText = [
                'single' => 'Одиночный',
                'integrated' => 'Интегрированный',
                'comparative' => 'Сравнительный',
                'series_integrated' => 'Анализ серии снов',
            ][$analysisType] ?? 'Анализ';
        }
        
        // Дата создания
        $date = $interpretation->created_at ? $interpretation->created_at->format('d.m.Y') : '';
        
        $seoResult = self::get('dream-analyzer-result', $interpretation->hash, [
            'dream_title' => $dreamTitle,
            'core_message' => $coreMessage,
            'date' => $date,
            'traditions' => $traditionsText,
            'analysis_type' => $analysisTypeText,
            'hash' => $interpretation->hash,
        ]);
        
        // Для серии снов изменяем title и h1 на множественное число
        if ($isSeries) {
            $seoResult['title'] = str_replace('Толкование сна', 'Толкование снов', $seoResult['title']);
            $seoResult['og_title'] = str_replace('расшифровка сна', 'расшифровка снов', $seoResult['og_title']);
            if (isset($seoResult['h1'])) {
                $seoResult['h1'] = str_replace('Расшифровка сна', 'Расшифровка снов', $seoResult['h1']);
            }
        }
        
        return $seoResult;
    }
}










